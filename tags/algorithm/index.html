<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>标签: algorithm - Slack Ideas</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="CAI SKI"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="CAI SKI"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Slack Ideas"><meta property="og:url" content="https://www.slackideas.com/"><meta property="og:site_name" content="Slack Ideas"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.slackideas.com/img/og_image.png"><meta property="article:author" content="caiski"><meta property="article:tag" content="Slack Ideas, Slack, Ideas"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.slackideas.com"},"headline":"Slack Ideas","image":["https://www.slackideas.com/img/og_image.png"],"author":{"@type":"Person","name":"caiski"},"publisher":{"@type":"Organization","name":"Slack Ideas","logo":{"@type":"ImageObject","url":"https://www.slackideas.com/about/index/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Slack Ideas" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/about/index/logo.svg" alt="Slack Ideas" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">algorithm</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-12-06T10:14:17.000Z" title="12/6/2015, 6:14:17 PM">2015-12-06</time>发表</span><span class="level-item"><time dateTime="2022-04-16T11:47:46.722Z" title="4/16/2022, 7:47:46 PM">2022-04-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/IT/">IT</a></span><span class="level-item">5 分钟读完 (大约708个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/12/06/Flood-Fill-Algorithm/">Flood Fill Algorithm</a></h1><div class="content"><p>The algorithm<br>Flood fill is an algorithm that determines the area connected to a given node in a multi-dimensional array. It is used in MS-Paint program as the “bucket” fill tool to fill connected, same-colored areas with one new color, and in games such as Go and Minesweeper for determining which pieces are cleared. In graphic processing, it is also known as boundary fill to fill a particular bounded area with color.</p>
<p>The flood-fill algorithm takes three parameters: a start node, a target color, and a replacement color. The algorithm looks for all nodes in the array that are connected to the start node by a path of the target color and changes them to the replacement color.</p>
<p>Strucuring the algorthm can be done in many ways, but they all make use of a queue or stack data structure, explicitly or implicitly.</p>
<p>Depending on whether we consider nodes touching at the corners connected or not, we have two variations: eight-way and four-way respectively.</p>
<p>Implementations<br>Stack-based(recursive) flood fill</p>
<pre><code>Flood-fill ( node, target-color, replacement-color ):
1.If the color of node is not equal to target-color, return;
2.Set the color of node to replacement-color.
3.Perform Flood-fill ( one step to the west of node, target-color, replacement-color).
  Perform Flood-fill ( one step to the east of node, target-color, replacement-color).
  Perform Flood-fill ( one step to the north of node, target-color, replacement-color).
  Perform Flood-fill ( one step to the south of node, target-color, replacement-color).
4.Return.
</code></pre>
<p>Queue-based flood fill</p>
<pre><code>Flood-fill ( node, target-color, replacement-color ):
1.Set Q to the empty queue.
2.If the color of node is not equal to target-color, return.
3.Add node to the end of Q.
4.For each element n of Q:
5\. Set the color of n to replacement-color.
6\. If the color of the node to the west of n is target-color, add that node to the end of Q.
   If the color of the node to the east of n is target-color, add that node to the end of Q.
   If the color of the node to the north of n is target-color, add that node to the end of Q.
   If the color of the node to the south of n is target-color, add that node to the end of Q.
7.Continue looping until Q is exhausted.
8.Return.
</code></pre>
<p>Queue-based flood fill with overhead optimization</p>
<pre><code>Flood-fill ( node, target-color, replacement-color ):
1.Set Q to the empty queue.
2.If the color of node is not equal to target-color, return.
3.Add node to the end of Q.
4.For each element n of Q:
5\. Set w and e equal to n.
6\. Move w to the west until the color of the node to the west of w no longer matches target-color.
7\. Move e to the east until the color of the node to the east of e no longer matches target-color.
8\. Set the color of nodes between w and e to replacement-color.
9\. For each node n between w and e:
10\. If the color of the node to the north of n is target-color, add that node to the end of Q.
    If the color of the node to the south of n is target-color, add that node to the end of Q.
11.Continue looping until Q is exhausted.
12.Return.
</code></pre>
<p>Working code in Java version:</p>
<pre><code>public void floodFill(BufferedImage image, Point node, Color targetColor, Color replacementColor) &#123;
  int width = image.getWidth();
  int height = image.getHeight();
  int target = targetColor.getRGB();
  int replacement = replacementColor.getRGB();
  if (target != replacement) &#123;
    Deque&lt;Point&gt; queue = new LinkedList&lt;Point&gt;();
    do &#123;
      int x = node.x;
      int y = node.y;
      while (x &gt; 0 &amp;&amp; image.getRGB(x - 1, y) == target) &#123;
        x--;
      &#125;
      boolean spanUp = false;
      boolean spanDown = false;
      while (x &lt; width &amp;&amp; image.getRGB(x, y) == target) &#123;
        image.setRGB(x, y, replacement);
        if (!spanUp &amp;&amp; y &gt; 0 &amp;&amp; image.getRGB(x, y - 1) == target) &#123;
          queue.add(new Point(x, y - 1));
          spanUp = true;
        &#125; else if (spanUp &amp;&amp; y &gt; 0 &amp;&amp; image.getRGB(x, y - 1) != target) &#123;
          spanUp = false;
        &#125;
        if (!spanDown &amp;&amp; y &lt; height - 1 &amp;&amp; image.getRGB(x, y + 1) == target) &#123;
          queue.add(new Point(x, y + 1));
          spanDown = true;
        &#125; else if (spanDown &amp;&amp; y &lt; height - 1 &amp;&amp; image.getRGB(x, y + 1) != target) &#123;
          spanDown = false;
        &#125;
        x++;
      &#125;
    &#125; while ((node = queue.pollFirst()) != null);
  &#125;
```&#125;
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2014-09-11T10:14:17.000Z" title="9/11/2014, 6:14:17 PM">2014-09-11</time>发表</span><span class="level-item"><time dateTime="2022-04-16T11:47:46.722Z" title="4/16/2022, 7:47:46 PM">2022-04-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/IT/">IT</a></span><span class="level-item">4 分钟读完 (大约595个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2014/09/11/Longest-Common-Substring/">Longest Common Substring</a></h1><div class="content"><p>Longest Common Substring问题描述如下：</p>
<p>给定一个query和一个text，均由小写字母组成。要求在text中找出以同样的顺序连续出现在query中的最长连续字母序列的长度。例如， query为”acbac”，text为”acaccbabb”，那么text中的”cba”为最长的连续出现在query中的字母序列，因此，返回结果应该为其长度3。请注意程序效率。</p>
<p>假设text长为T，query长为Q。</p>
<h1 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h1><p>很多人的第一想法就是罗列出query和text的所有子串，挨个比较，取出二者都有的子串，最后返回最长的子串长度。</p>
<p>算法的时间复杂度将为O(T^2 * Q^2)</p>
<pre><code>int get_max_sub_bf(const char* text, const char* query) &#123;
    // Time O(T^2 * Q^2)
    int T = strlen(text);
    int Q = strlen(query);
    int max = -1;
    int flag;
    for (int i = 0; i &lt; T; i++) &#123;
        for (int ii = 0; ii &lt; T - i; ii++) &#123;
            //text[i, ii+i]
            for (int j = 0; j &lt; Q; j++) &#123;
                for (int jj = 0; jj &lt; Q - j; jj++) &#123;
                    // query[j, jj+j]
                    if(jj==ii) &#123;
                        flag=1;
                        for(int k = 0;k &lt; ii; k++) &#123;
                            if(text[i+k]!=query[j+k]) &#123;
                                flag = 0;
                                break;
                            &#125;
                        &#125;
                        if(flag &amp;&amp; (max&lt;ii)) &#123;
                            max=ii;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return max;
&#125;
</code></pre>
<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><p>典型的以空间换时间，但是用到了子字符串的相关规律。</p>
<p>假设dp[i][j]是字符串text[0…i]和query[0…j]的最长公共子串长度。</p>
<p>那么有：若text[i]==query[j]，则dp[i][j]=dp[i-1][j-1] + 1。</p>
<p>算法复杂度：时间O(T * Q), 空间O(T * Q)。</p>
<pre><code>int get_max_sub_dp(const char* text, const char* query) &#123;
    // Time O(T*Q)
    // Space O(T*Q)
    int T = strlen(text);
    int Q = strlen(query);
    int dp[T][Q];
    for(int i = 0 ; i &lt; T; i ++)
    &#123;
        for(int j = 0; j &lt; Q; j ++)
        &#123;
            dp[i][j] = 0;
        &#125;
    &#125;
    // dp[i][j]表示T[0...i]和Q[0...j]的最大公共子串长度
    int max = -1;
    for (int i = 1; i &lt; T; i++) &#123;
        for (int j = 1; j &lt; Q; j++) &#123;
            if (text[i - 1] == query[j - 1]) &#123;
                dp[i][j] = dp[i-1][j-1] + 1;
                if(max&lt;dp[i][j]) &#123;
                    printf(&quot;dp[%d][%d]\n&quot;, i, j);
                    max=dp[i][j];
                &#125;
            &#125;
        &#125;
    &#125;
    return max;
&#125;
</code></pre>
<h1 id="测试与比较"><a href="#测试与比较" class="headerlink" title="测试与比较"></a>测试与比较</h1><p>首先需要有测试用的text和query，我在Linux环境用Shell命令生成随机字符串。</p>
<pre><code>rm -f in.dat
####生成长度为1000的text字符串到in.dat第一行
tr -cd &#39;[:alnum:]&#39; &lt; /dev/urandom | fold -w1000 | head -n1 &gt; in.dat
####生成长度为100的query字符串到in.dat第一行
tr -cd &#39;[:alnum:]&#39; &lt; /dev/urandom | fold -w100 | head -n1 &gt;&gt; in.dat
</code></pre>
<p>编写C代码，读取text和query，用两种方法进行测试，在标准输出打印所用时间。</p>
<pre><code>#include &lt;sys/time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;time.h&gt;
int timeval_subtract(struct timeval *result, struct timeval *t2, struct timeval *t1)
&#123;
    long int diff = (t2-&gt;tv_usec + 1000000 * t2-&gt;tv_sec) - (t1-&gt;tv_usec + 1000000 * t1-&gt;tv_sec);
    result-&gt;tv_sec = diff / 1000000;
    result-&gt;tv_usec = diff % 1000000;

    return (diff&lt;0);
&#125;
void timeval_print(struct timeval *tv)
&#123;
    char buffer[30];
    time_t curtime;

    printf(&quot;%ld.%06ld&quot;, tv-&gt;tv_sec, tv-&gt;tv_usec);
    curtime = tv-&gt;tv_sec;
    strftime(buffer, 30, &quot;%m-%d-%Y  %T&quot;, localtime(&amp;curtime));
    printf(&quot; = %s.%06ld\n&quot;, buffer, tv-&gt;tv_usec);
&#125;
int main(int argc, char* argv[])
&#123;
    struct timeval tvBegin, tvEnd, tvDiff;
    char *text= NULL;
    char *query= NULL;
    FILE *in = fopen(&quot;in.dat&quot;,&quot;r&quot;);
    size_t len=0;
    if(in==NULL) return -1;
    getline(&amp;text, &amp;len, in);
    getline(&amp;query, &amp;len, in);
    printf(&quot;%s&quot;, text);
    printf(&quot;%s&quot;, query);
    fclose(in);

    // dp
    gettimeofday(&amp;tvBegin, NULL);
    printf(&quot;lcs %d\n&quot;, get_max_sub_dp(text,query));
    gettimeofday(&amp;tvEnd, NULL);
    timeval_subtract(&amp;tvDiff, &amp;tvEnd, &amp;tvBegin);
    printf(&quot;dp time elapsed %ld.%06ld s\n&quot;, tvDiff.tv_sec, tvDiff.tv_usec);

    // br
    gettimeofday(&amp;tvBegin, NULL);
    printf(&quot;lcs %d\n&quot;, get_max_sub_bf(text,query));
    gettimeofday(&amp;tvEnd, NULL);
    timeval_subtract(&amp;tvDiff, &amp;tvEnd, &amp;tvBegin);
    printf(&quot;bf time elapsed %ld.%06ld s\n&quot;, tvDiff.tv_sec, tvDiff.tv_usec);

    return 0;
&#125;
</code></pre>
<p>编译代码<code>gcc common_sub_str.c -o common_sub_str</code></p>
<p>运行./common_sub_str</p>
<p>得出结果：</p>
<pre><code>dp time elapsed 0.002574 s
bf time elapsed 5.522046 s
</code></pre>
<p>实验重复两次，都是得到dp的时间效率高出bf近2000倍。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2014-09-03T10:14:17.000Z" title="9/3/2014, 6:14:17 PM">2014-09-03</time>发表</span><span class="level-item"><time dateTime="2022-04-16T11:47:46.722Z" title="4/16/2022, 7:47:46 PM">2022-04-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/IT/">IT</a></span><span class="level-item">7 分钟读完 (大约1011个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2014/09/03/Pattern-Search-Algorithm-KMP/">Pattern Search Algorithm - KMP</a></h1><div class="content"><h1 id="模式搜索算法KMP"><a href="#模式搜索算法KMP" class="headerlink" title="模式搜索算法KMP"></a>模式搜索算法KMP</h1><p>为了说明算法细节，我们举一个实际例子来说明。假设W=”ABCDABD”，S=”ABC ABCDAB ABCDABCDABDE”。算法的状态在任意时刻都只由两个整数决定：</p>
<p>m表示S中可能匹配W的起始位置<br>i表示W中正在比较的字符下标 每一步中，我们比较S[m+i]和W[i]，如果相等则继续下一个字符。<br>1，从第一个字符开始匹配，因B与A不相等，故后移一位。<br>2，从第一个字符开始匹配，B与A不相等，再次后移。<br>3，直到有一个字符相同，继续往下比较，直到发现不同。<br>4，此时该后移多少？应该后移到如图位置。部分匹配值在后面说明。<br><em>移动位数</em> = 已匹配的字符数 - 对应的部分匹配值<br>根据相同原理，继续进行比较。<br>直到最后i一直匹配到W的最后一位，匹配成功。</p>
<p>6，下面介绍部分匹配值是如何计算的。<br>首先，有两个概念：“前缀”和“后缀”。有如下定义：前缀指除了最后一个字符以外，一个字符串的全部头部组合；“后缀”指除了第一个字符以外，一个字符串的全部尾部组合。<br>在此基础上，“部分匹配值”就是“前缀”和“后缀”中最长的公共元素的长度。以ABCDABD为例：</p>
<p>“A”的前缀和后缀都为空集，共有元素的长度为0；<br>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；<br>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；<br>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；<br>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；<br>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；<br>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p>
<p>“部分匹配”实质是字符串头部和尾部可能有重复的串，搜索移动的时候，我们能通过此规则跳过一定的字符，达到减小复杂度的目的。</p>
<h1 id="KMP算法的效率"><a href="#KMP算法的效率" class="headerlink" title="KMP算法的效率"></a>KMP算法的效率</h1><p>算法的两部分“计算部分匹配值”和“寻找匹配串”，复杂度分别为O(n)和O(k)，因此算法整体复杂度为O(n+k)。这项复杂度不因W和S中的重复模式数目而改变。</p>
<p>最后放上实现代码</p>
<pre><code>public class KMP &#123;
    // kmp算法实现，返回所有匹配处的下标
    static ArrayList&lt;Integer&gt; kmp_search(char[] target, char[] pattern) &#123;
        if (target == null || pattern == null) &#123;
            throw new IllegalArgumentException(&quot;null char array&quot;);// null param
        &#125;
        if (target.length == 0 || pattern.length == 0
                || pattern.length &gt; target.length) &#123;
            throw new IllegalArgumentException(&quot;invalid parameter&quot;);// err return
        &#125;
        int[] pmt = get_pmt(pattern);//获取部分匹配数组
        ArrayList&lt;Integer&gt; kmpResult = new ArrayList&lt;Integer&gt;();
        int S = target.length;// target 元素个数
        int W = pattern.length;// pattern 元素个数
        int delta;//表示patter该往后移动的位数
        int m;// m表示target中可能匹配W的起始位置
        int i;// i表示pattern中正在比较的字符下标
        for (m = 0; m &lt; S - W + 1; m += delta) &#123;
            delta = 1;
            for (i = 0; i &lt; W; i++) &#123;
                if (pattern[i] != target[m + i]) &#123;
                    if (i != 0)
                        delta = (i - pmt[i - 1]);
                    break;
                &#125;
            &#125;
            if (i == W) &#123;
                kmpResult.add(m);
            &#125;
        &#125;
        return kmpResult;
    &#125;

    // 生成部分匹配表
    static int[] get_pmt(char[] pattern) &#123;
        int len = pattern.length;
        int[] pmt = new int[len];
        int i, j, k, max_cc;
        for (i = 0; i &lt; len; i++) &#123;
            max_cc = 0;
            // prefix pattern[0...j]
            // postfix pattern[k...i]
            for (j = 0; j &lt; i; j++) &#123;
                for (k = 0; k &lt;= j; k++) &#123;
                    if (pattern[k] != pattern[i - j + k]) &#123;
                        break;
                    &#125;
                &#125;
                if (k == j + 1)
                    max_cc = Math.max(max_cc, k);
            &#125;
            pmt[i] = max_cc;
        &#125;
        return pmt;
    &#125;

    public static void main(String[] args) &#123;
    // 测试
        char[] target = &quot;AABAACAADAABAAABAA&quot;.toCharArray();
        char[] pattern = &quot;ABAA&quot;.toCharArray();
        System.out.println(kmp_search(target, pattern));
    &#125;
&#125;
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2014-07-21T10:14:17.000Z" title="7/21/2014, 6:14:17 PM">2014-07-21</time>发表</span><span class="level-item"><time dateTime="2022-04-16T11:47:46.722Z" title="4/16/2022, 7:47:46 PM">2022-04-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/IT/">IT</a></span><span class="level-item">6 分钟读完 (大约960个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2014/07/21/How-Does-Namenode-Find-The-Nearest-Datanode/">How Does Namenode Find The Nearest Datanode</a></h1><div class="content"><p>问题的全部：客户端每次都首先与Namenode通信，然后与Namenode指定的Datanode直接读或写数据。这里Namenode会找到离Client最近的Datanode交给Client，请问这个步骤是如何实现的？</p>
<p>根据层次的加深，我有三个不同的答案：</p>
<p>有NameNode确定客户端所在的网络，然后找到一个具有某Blocks的与Client在同一个局域网或机架的数据节点<br>NameNode维护着一个集群的网络拓扑结构，在这个图中可以确定与Client最近的具有某Blocks的数据节点<br>从源码级别来看，NameNode用了什么函数来做这件事情。<br>个人觉得第三个答案是最好的，Talk is cheap, show me the code。</p>
<p>“输入流和输出流是DFSClient实现中最复杂的部分，它们不但需要和名字节点通信，还需要访问数据节点。相比之下，输入流比输出流简单，读数据的过程中，名字节点只提供了两个远程方法，getBlockLocations()和reportBadBlocks()。”</p>
<p>客户端在读取数据前先要向NameNode调用RPC获得BlockLocations，这个过程中NameNode就会提供与客户端最近的数据节点给它。NameNode.getBlockLocations()代码如下：</p>
<pre><code>/**org.apache.hadoop.hdfs.server.namenode.NameNode*/
/** &#123;@inheritDoc&#125; */
public LocatedBlocks getBlockLocations(String src,
    long offset,
    long length) throws IOException &#123;
    myMetrics.incrNumGetBlockLocations();//统计计数
    return namesystem.getBlockLocations(getClientMachine(),
        src, offset, length);//获取BlockLocations
&#125;
/**获取Client的地址*/
private static String getClientMachine() &#123;
    String clientMachine = NamenodeWebHdfsMethods.getRemoteAddress();
    if (clientMachine == null) &#123; //not a web client
        clientMachine = Server.getRemoteAddress();
    &#125;
    if (clientMachine == null) &#123; //not a RPC client
        clientMachine = &quot;&quot;;
    &#125;
    return clientMachine;
&#125;
</code></pre>
<p>重点来了。</p>
<pre><code>/**
 * Get block locations within the specified range.
 *
 * @see #getBlockLocations(String, long, long)
 */
LocatedBlocks getBlockLocations(String clientMachine, String src,
        long offset, long length) throws IOException &#123;
    LocatedBlocks blocks = getBlockLocations(src, offset, length, true,
            true, true);// 1，获取源文件所在的所有Block
    if (blocks != null) &#123;
        // sort the blocks 2，打算将这些Block按从近到远进行排序
        // In some deployment cases, cluster is with separation of task
        // tracker
        // and datanode which means client machines will not always be
        // recognized
        // as known data nodes, so here we should try to get node (but not
        // datanode only) for locality based sort.
        Node client = host2DataNodeMap.getDatanodeByHost(clientMachine);// 3，查看client是否是DataNode节点
        if (client == null) &#123;// 3.1，若不是，则对client进行dns解析生成一个NodeBase
            List&lt;String&gt; hosts = new ArrayList&lt;String&gt;(1);
            hosts.add(clientMachine);
            String rName = dnsToSwitchMapping.resolve(hosts).get(0);
            if (rName != null)
                client = new NodeBase(clientMachine, rName);
        &#125;

        DFSUtil.StaleComparator comparator = null;
        if (avoidStaleDataNodesForRead) &#123;
            comparator = new DFSUtil.StaleComparator(staleInterval);
        &#125;
        // Note: the last block is also included and sorted
        // 4，将所有Block所在位置与Client进行比较，然后按比较结果从小到大排序
        for (LocatedBlock b : blocks.getLocatedBlocks()) &#123;
            // 4.1，使用NetworkTopology实例clusterMap进行排序
            clusterMap.pseudoSortByDistance(client, b.getLocations());
            if (avoidStaleDataNodesForRead) &#123;
                Arrays.sort(b.getLocations(), comparator);
            &#125;
        &#125;
    &#125;
    return blocks;
&#125;
</code></pre>
<p>排序代码</p>
<pre><code>/**
 * Get block locations within the specified range.
 *
 * @see #getBlockLocations(String, long, long)
 */
LocatedBlocks getBlockLocations(String clientMachine, String src,
        long offset, long length) throws IOException &#123;
    LocatedBlocks blocks = getBlockLocations(src, offset, length, true,
            true, true);// 1，获取源文件所在的所有Block
    if (blocks != null) &#123;
        // sort the blocks 2，打算将这些Block按从近到远进行排序
        // In some deployment cases, cluster is with separation of task
        // tracker
        // and datanode which means client machines will not always be
        // recognized
        // as known data nodes, so here we should try to get node (but not
        // datanode only) for locality based sort.
        Node client = host2DataNodeMap.getDatanodeByHost(clientMachine);// 3，查看client是否是DataNode节点
        if (client == null) &#123;// 3.1，若不是，则对client进行dns解析生成一个NodeBase
            List&lt;String&gt; hosts = new ArrayList&lt;String&gt;(1);
            hosts.add(clientMachine);
            String rName = dnsToSwitchMapping.resolve(hosts).get(0);
            if (rName != null)
                client = new NodeBase(clientMachine, rName);
        &#125;

        DFSUtil.StaleComparator comparator = null;
        if (avoidStaleDataNodesForRead) &#123;
            comparator = new DFSUtil.StaleComparator(staleInterval);
        &#125;
        // Note: the last block is also included and sorted
        // 4，将所有Block所在位置与Client进行比较，然后按比较结果从小到大排序
        for (LocatedBlock b : blocks.getLocatedBlocks()) &#123;
            // 4.1，使用NetworkTopology实例clusterMap进行排序
            clusterMap.pseudoSortByDistance(client, b.getLocations());
            if (avoidStaleDataNodesForRead) &#123;
                Arrays.sort(b.getLocations(), comparator);
            &#125;
        &#125;
    &#125;
    return blocks;
&#125;
</code></pre>
<p>至此，这个过程算是大概明白了。但是还需要结合整个Namenode的数据结构来看才行，不然就一叶障目不见泰山了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2013-09-14T10:14:17.000Z" title="9/14/2013, 6:14:17 PM">2013-09-14</time>发表</span><span class="level-item"><time dateTime="2022-04-16T11:47:46.722Z" title="4/16/2022, 7:47:46 PM">2022-04-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/IT/">IT</a></span><span class="level-item">7 分钟读完 (大约1048个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2013/09/14/My-Implementation-Of-Apriori-Algorithm/">My Implementation Of Apriori Algorithm</a></h1><div class="content"><p>项目需要分布式的代码，于是先看了下算法思想，自己学着单机实现了一下。复杂度比较高，其中有两个递归实现。由于Java提供的Set都没有实现Comparable接口，所以自定义了一个Set叫做SimpleSet，其中实现了hashCode, equals, compareTo等函数。</p>
<p>以下代码完全没有指导意义，只作为个人工作记录。</p>
<p>代码如下：</p>
<p>SimpleSet.java</p>
<pre><code class="java">import java.io.*;
import java.util.*;

public class SimpleSet&lt;T&gt; implements Set, Comparable&#123;
    static int i  =0;
    Set&lt;T&gt; set = new HashSet&lt;T&gt;();

    public SimpleSet() &#123;

    &#125;
    public SimpleSet(SimpleSet ss) &#123;
        this.set.addAll(ss.set);

    &#125;

    public int hashCode() &#123;
        int type = this.getClass().hashCode();
        int code = 0;
        for(T t : this.set) &#123;
            code += (type*31 + t.hashCode());
        &#125;
        return code;
    &#125;
    public boolean equals(Object obj) &#123;
        boolean flag = false;
        if(obj instanceof SimpleSet) &#123;
            SimpleSet&lt;?&gt; s = (SimpleSet&lt;?&gt;)obj;
            if( (s.size()==this.size()) &amp;&amp; s.containsAll(this.set)&amp;&amp; this.set.containsAll(s)) &#123;
                flag = true;
            &#125;
        &#125;
        return flag;
    &#125;
    public String toString() &#123;
        if (this.set.size() == 0) &#123;
            return &quot;&quot;;
        &#125; else &#123;
            StringBuilder str = new StringBuilder();
            str.append(&quot;[&quot;);
            for (T t : this.set) &#123;
                str.append(t.toString() + &quot;,&quot;);
            &#125;
            String result = str.substring(0, str.length() - 1);
            result += &quot;]&quot;;
            return result;
        &#125;
    &#125;

    @Override
    public boolean add(Object e) &#123;
        return this.set.add((T) e);
    &#125;

    @Override
    public boolean addAll(Collection c) &#123;
        return this.set.addAll(c);
    &#125;

    @Override
    public void clear() &#123;
        this.set.clear();
    &#125;

    @Override
    public boolean contains(Object o) &#123;
        return this.set.contains(o);
    &#125;

    @Override
    public boolean containsAll(Collection c) &#123;
        return this.set.containsAll(c);
    &#125;

    @Override
    public boolean isEmpty() &#123;
        return this.set.isEmpty();
    &#125;

    @Override
    public Iterator iterator() &#123;
        return this.set.iterator();
    &#125;

    @Override
    public boolean remove(Object o) &#123;
        return this.set.remove(o);
    &#125;

    @Override
    public boolean removeAll(Collection c) &#123;
        return this.set.removeAll(c);
    &#125;

    @Override
    public boolean retainAll(Collection c) &#123;
        return this.set.retainAll(c);
    &#125;

    @Override
    public int size() &#123;
        return this.set.size();
    &#125;

    @Override
    public Object[] toArray() &#123;
        return this.set.toArray();
    &#125;

    public String[] toArray(String[] a) &#123;
        return this.set.toArray(a);
    &#125;

    @Override
    public Object[] toArray(Object[] a) &#123;
        // TODO DO NOT USE
        return null;
    &#125;
    @Override
    public int compareTo(Object o) &#123;
        return this.hashCode()-o.hashCode();
    &#125;
&#125;
Apriori.java

import java.util.*;
import java.io.*;

public class Apriori &#123;

    /**
     * @param args
     */
    static Map&lt;String, Integer&gt; data = new HashMap&lt;String, Integer&gt;();
    static List&lt;SimpleSet&lt;String&gt;&gt; lineSet = new ArrayList&lt;SimpleSet&lt;String&gt;&gt;();
    // all constructible combinations
    static Map&lt;SimpleSet&lt;String&gt;, Integer&gt; dataSet = new HashMap&lt;SimpleSet&lt;String&gt;, Integer&gt;();

    static final int MIN_SUP = 1;
    static final float MIN_CONF = 0.1f;
    static BufferedWriter bw1= null;
    static BufferedWriter bw2 = null;

    public static void main(String[] args) throws IOException &#123;
        bw1= new BufferedWriter(new FileWriter(&quot;FrequentPatterns.txt&quot;, true));
        bw2 = new BufferedWriter(new FileWriter(&quot;AssociationRules.txt&quot;, true));
        long startTime = System.currentTimeMillis();

        String srcFile = &quot;Test.txt&quot;;
        try &#123;
            data = buildData(srcFile);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        Map&lt;SimpleSet&lt;String&gt;, Integer&gt; result = getF1Set(data);
        Map&lt;SimpleSet&lt;String&gt;, Integer&gt; maxFICMap = new HashMap&lt;SimpleSet&lt;String&gt;, Integer&gt;();
        int i = 1;
        do &#123;
            printCandidate(result, i);
            i++;
            maxFICMap = result;
            result = recurseGen(result);
        &#125; while (result.size() &gt; 0);
        System.out.println(&quot;---------------------------Frequent Patterns---------------------------\n&quot;);
        long endTime1 = System.currentTimeMillis();
        System.out.println((endTime1 - startTime)+&quot; ms&quot;);
        //System.out.println(dataSet);
        //System.out.println(maxFICMap);

        List&lt;SimpleSet&lt;String&gt;&gt; maxFI = new ArrayList&lt;SimpleSet&lt;String&gt;&gt;(
                maxFICMap.keySet());
        System.out.println(&quot;---------------------------Association Rule---------------------------\n&quot;);
        calcAndPrintAsso(maxFI);
        long endTime2 = System.currentTimeMillis();
        System.out.println((endTime2 - endTime1)+&quot; ms&quot;);

        System.out.println(&quot;----------------------------Consumed Time----------------------------\n&quot;);
        long endTime3 = System.currentTimeMillis();
        System.out.println((endTime3 - startTime)+&quot; ms&quot;);
        bw1.close();
        bw2.close();
    &#125;

    private static void calcAndPrintAsso(List&lt;SimpleSet&lt;String&gt;&gt; maxFI) throws IOException &#123;
        for (SimpleSet&lt;String&gt; oneBigSet : maxFI) &#123;
            if (oneBigSet.size() &gt; 1) &#123;
                if (dataSet.containsKey(oneBigSet)) &#123;
                    int numerator = dataSet.get(oneBigSet);
                    List&lt;SimpleSet&lt;String&gt;&gt; subs = getSubsets(oneBigSet);
                    for (SimpleSet&lt;String&gt; sub : subs) &#123;
                        if (dataSet.containsKey(sub)) &#123;
                            int denominator = dataSet.get(sub);
                            float confidence = (float) numerator / denominator;
                            bw2.write(sub.toString() + &quot; --&gt; &quot; + oneBigSet.toString()
                                    + &quot; conf=&quot; + confidence);
                            bw2.newLine();
                        &#125;
                    &#125;
                    calcAndPrintAsso(subs);
                &#125;
            &#125;
        &#125;
    &#125;

    private static void printCandidate(Map&lt;SimpleSet&lt;String&gt;, Integer&gt; result,
            int i) throws IOException &#123;
        int size = result.size();
        bw1.write(i + &quot;-item set (num: &quot; + size + &quot;):\n&quot;);
        bw1.write(result.toString());
        bw1.newLine();
    &#125;

    private static Map&lt;SimpleSet&lt;String&gt;, Integer&gt; recurseGen(
            Map&lt;SimpleSet&lt;String&gt;, Integer&gt; preMap) &#123;
        List&lt;SimpleSet&lt;String&gt;&gt; keyList = new ArrayList&lt;SimpleSet&lt;String&gt;&gt;();
        keyList.addAll(preMap.keySet());
        Map&lt;SimpleSet&lt;String&gt;, Integer&gt; result = new HashMap&lt;SimpleSet&lt;String&gt;, Integer&gt;();
        int preSize = keyList.size();
        for (int i = 0; i &lt; preSize - 1; i++) &#123;
            for (int j = i + 1; j &lt; preSize; j++) &#123;
                SimpleSet&lt;String&gt; key1 = keyList.get(i);
                SimpleSet&lt;String&gt; key2 = keyList.get(j);
                String[] pre1 = key1.toArray(new String[0]);
                String[] pre2 = key2.toArray(new String[0]);
                if (maybeLinkable(pre1, pre2)) &#123;
                    SimpleSet&lt;String&gt; superSet = new SimpleSet&lt;String&gt;();
                    int count = 0;
                    for (String str : pre1) &#123;
                        superSet.add(str);
                    &#125;
                    superSet.add(pre2[pre2.length - 1]);

                    if (!shouldCut(keyList, superSet)) &#123;
                        count = checkSup(superSet);
                        if (count &gt;= MIN_SUP) &#123;
                            result.put(superSet, count);
                            dataSet.put(superSet, count);// construct global
                                                            // reference
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return result;
    &#125;

    private static int checkSup(SimpleSet&lt;String&gt; superSet) &#123;
        int count = 0;
        for (SimpleSet&lt;String&gt; line : lineSet) &#123;
            if (line.containsAll(superSet)) &#123;
                count++;
            &#125;
        &#125;
        return count;
    &#125;

    private static boolean shouldCut(List&lt;SimpleSet&lt;String&gt;&gt; preKeyList,
            SimpleSet&lt;String&gt; superSet) &#123;
        boolean flag = false;
        List&lt;SimpleSet&lt;String&gt;&gt; subsets = getSubsets(superSet);
        for (SimpleSet&lt;String&gt; s : subsets) &#123;
            if (!preKeyList.contains(s)) &#123;
                flag = true;
                break;
            &#125;
        &#125;
        return flag;
    &#125;

    private static List&lt;SimpleSet&lt;String&gt;&gt; getSubsets(SimpleSet&lt;String&gt; superSet) &#123;
        List&lt;SimpleSet&lt;String&gt;&gt; subsets = new ArrayList&lt;SimpleSet&lt;String&gt;&gt;();
        String[] superList = superSet.toArray(new String[0]);
        for (int i = 0; i &lt; superList.length; i++) &#123;
            SimpleSet&lt;String&gt; copyOfSuperSet = new SimpleSet&lt;String&gt;(superSet);
            copyOfSuperSet.remove(superList[i]);
            /*
             * SimpleSet&lt;String&gt; temp = new SimpleSet&lt;String&gt;();
             *
             * for (int j = 0; j &lt; superList.length; j++) &#123; if (i != j) &#123;
             * temp.add(superList[i]); &#125; &#125;
             */subsets.add(copyOfSuperSet);
        &#125;
        return subsets;
    &#125;

    private static boolean maybeLinkable(String[] pre1, String[] pre2) &#123;
        boolean flag = true;
        int size1 = pre1.length;
        int size2 = pre2.length;
        if (size1 == size2) &#123;
            if (size1 != 0) &#123;
                for (int i = 0; i &lt; size1 - 1; i++) &#123;
                    if (!pre1[i].equals(pre2[i])) &#123;
                        flag = false;
                        break;
                    &#125;
                &#125;
                if (pre1[size1 - 1].equals(pre2[size2 - 1])) &#123;
                    flag = false;

                &#125;
            &#125; else &#123;
                flag = false;
            &#125;
        &#125; else &#123;
            flag = false;
        &#125;
        return flag;
    &#125;

    private static HashMap&lt;SimpleSet&lt;String&gt;, Integer&gt; getF1Set(
            Map&lt;String, Integer&gt; srcdata) &#123;
        HashMap&lt;SimpleSet&lt;String&gt;, Integer&gt; f1Set = new HashMap&lt;SimpleSet&lt;String&gt;, Integer&gt;();
        for (String str : srcdata.keySet()) &#123;
            int count = srcdata.get(str);
            if (count &gt;= MIN_SUP) &#123;
                SimpleSet&lt;String&gt; set = new SimpleSet&lt;String&gt;();
                set.add(str);
                f1Set.put(set, count);// Be Strict !
                dataSet.put(set, count);
            &#125;
        &#125;
        return f1Set;
    &#125;

    static Map&lt;String, Integer&gt; buildData(String... files) throws IOException &#123;
        Map&lt;String, Integer&gt; tdata = new HashMap&lt;String, Integer&gt;();
        BufferedReader br = new BufferedReader(new FileReader(files[0]));
        String line;
        String[] col;
        while ((line = br.readLine()) != null) &#123;
            SimpleSet&lt;String&gt; line_items = new SimpleSet&lt;String&gt;();
            col = line.split(&quot; &quot;);
            for (String str : col) &#123;
                line_items.add(str);
                if (!tdata.containsKey(str)) &#123;
                    tdata.put(str, 1);
                &#125; else &#123;
                    int i = tdata.get(str);
                    tdata.put(str, i + 1);// TODO
                &#125;
            &#125;
            lineSet.add(line_items);
        &#125;
        br.close();
        return tdata;
    &#125;
&#125;
</code></pre>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/about/index/logo.svg" alt="CAISKI"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">CAISKI</p><p class="is-size-6 is-block">Engineer at Tencent Inc.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">55</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">24</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/caiski" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/caiski"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/imskicai"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="/PostgresWorld" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Postgres World</span></span><span class="level-right"><span class="level-item tag">/PostgresWorld</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/IT/"><span class="level-start"><span class="level-item">IT</span></span><span class="level-end"><span class="level-item tag">35</span></span></a></li><li><a class="level is-mobile" href="/categories/Other/"><span class="level-start"><span class="level-item">Other</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-01T12:02:38.000Z">2022-07-01</time></p><p class="title"><a href="/2022/07/01/Commonly-Used-Tools-Website-v2022/">Commonly Used Tools Website v2022</a></p><p class="categories"><a href="/categories/Other/">Other</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-10T03:01:05.000Z">2021-10-10</time></p><p class="title"><a href="/2021/10/10/Li-Assisted-Driving-in-Long-Distance-Road-Trip/">Li Assisted Driving in Long Distance Road Trip</a></p><p class="categories"><a href="/categories/Other/">Other</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-22T07:16:56.000Z">2021-08-22</time></p><p class="title"><a href="/2021/08/22/Data-Type-Mappings-Between-Golang-And-PostgreSQL/">Data Type Mappings Between Golang And PostgreSQL</a></p><p class="categories"><a href="/categories/IT/">IT</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-18T05:16:42.000Z">2021-07-18</time></p><p class="title"><a href="/2021/07/18/A-Glance-Through-the-Window-of-Office-Two-Pictures/">A Glance Through the Window of Office (Two Pictures)</a></p><p class="categories"><a href="/categories/Other/">Other</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-17T12:14:17.000Z">2021-07-17</time></p><p class="title"><a href="/2021/07/17/Alfred-New-User-Notes-Part-I/">Alfred New User Notes - Part I</a></p><p class="categories"><a href="/categories/Other/">Other</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/08/"><span class="level-start"><span class="level-item">八月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/07/"><span class="level-start"><span class="level-item">七月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">一月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/12/"><span class="level-start"><span class="level-item">十二月 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/11/"><span class="level-start"><span class="level-item">十一月 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/10/"><span class="level-start"><span class="level-item">十月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/12/"><span class="level-start"><span class="level-item">十二月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/11/"><span class="level-start"><span class="level-item">十一月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/09/"><span class="level-start"><span class="level-item">九月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/08/"><span class="level-start"><span class="level-item">八月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/07/"><span class="level-start"><span class="level-item">七月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/06/"><span class="level-start"><span class="level-item">六月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/04/"><span class="level-start"><span class="level-item">四月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/12/"><span class="level-start"><span class="level-item">十二月 2014</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/09/"><span class="level-start"><span class="level-item">九月 2014</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/07/"><span class="level-start"><span class="level-item">七月 2014</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/09/"><span class="level-start"><span class="level-item">九月 2013</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2012/09/"><span class="level-start"><span class="level-item">九月 2012</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2012/07/"><span class="level-start"><span class="level-item">七月 2012</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2010/12/"><span class="level-start"><span class="level-item">十二月 2010</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2010/11/"><span class="level-start"><span class="level-item">十一月 2010</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/alfred/"><span class="tag">alfred</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/algorithm/"><span class="tag">algorithm</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/blockchain/"><span class="tag">blockchain</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpp/"><span class="tag">cpp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/design-pattern/"><span class="tag">design pattern</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/emerg/"><span class="tag">emerg</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iptables/"><span class="tag">iptables</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mac/"><span class="tag">mac</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/photography/"><span class="tag">photography</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgresql/"><span class="tag">postgresql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/regex/"><span class="tag">regex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rpc/"><span class="tag">rpc</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssh/"><span class="tag">ssh</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tex/"><span class="tag">tex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thoughts/"><span class="tag">thoughts</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tool/"><span class="tag">tool</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/trial/"><span class="tag">trial</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tricks/"><span class="tag">tricks</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/about/index/logo.svg" alt="Slack Ideas" height="28"></a><p class="is-size-7"><span>&copy; 2022 caiski</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
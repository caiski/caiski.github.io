<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Slack Ideas</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="CAI SKI"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="CAI SKI"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Slack Ideas"><meta property="og:url" content="https://www.slackideas.com/"><meta property="og:site_name" content="Slack Ideas"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.slackideas.com/img/og_image.png"><meta property="article:author" content="caiski"><meta property="article:tag" content="Slack Ideas, Slack, Ideas"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.slackideas.com"},"headline":"Slack Ideas","image":["https://www.slackideas.com/img/og_image.png"],"author":{"@type":"Person","name":"caiski"},"publisher":{"@type":"Organization","name":"Slack Ideas","logo":{"@type":"ImageObject","url":"https://www.slackideas.com/about/index/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Slack Ideas" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/about/index/logo.svg" alt="Slack Ideas" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2014-09-11T10:14:17.000Z" title="9/11/2014, 6:14:17 PM">2014-09-11</time>发表</span><span class="level-item"><time dateTime="2022-04-16T11:47:46.722Z" title="4/16/2022, 7:47:46 PM">2022-04-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/IT/">IT</a></span><span class="level-item">4 分钟读完 (大约595个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2014/09/11/Longest-Common-Substring/">Longest Common Substring</a></h1><div class="content"><p>Longest Common Substring问题描述如下：</p>
<p>给定一个query和一个text，均由小写字母组成。要求在text中找出以同样的顺序连续出现在query中的最长连续字母序列的长度。例如， query为”acbac”，text为”acaccbabb”，那么text中的”cba”为最长的连续出现在query中的字母序列，因此，返回结果应该为其长度3。请注意程序效率。</p>
<p>假设text长为T，query长为Q。</p>
<h1 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h1><p>很多人的第一想法就是罗列出query和text的所有子串，挨个比较，取出二者都有的子串，最后返回最长的子串长度。</p>
<p>算法的时间复杂度将为O(T^2 * Q^2)</p>
<pre><code>int get_max_sub_bf(const char* text, const char* query) &#123;
    // Time O(T^2 * Q^2)
    int T = strlen(text);
    int Q = strlen(query);
    int max = -1;
    int flag;
    for (int i = 0; i &lt; T; i++) &#123;
        for (int ii = 0; ii &lt; T - i; ii++) &#123;
            //text[i, ii+i]
            for (int j = 0; j &lt; Q; j++) &#123;
                for (int jj = 0; jj &lt; Q - j; jj++) &#123;
                    // query[j, jj+j]
                    if(jj==ii) &#123;
                        flag=1;
                        for(int k = 0;k &lt; ii; k++) &#123;
                            if(text[i+k]!=query[j+k]) &#123;
                                flag = 0;
                                break;
                            &#125;
                        &#125;
                        if(flag &amp;&amp; (max&lt;ii)) &#123;
                            max=ii;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return max;
&#125;
</code></pre>
<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><p>典型的以空间换时间，但是用到了子字符串的相关规律。</p>
<p>假设dp[i][j]是字符串text[0…i]和query[0…j]的最长公共子串长度。</p>
<p>那么有：若text[i]==query[j]，则dp[i][j]=dp[i-1][j-1] + 1。</p>
<p>算法复杂度：时间O(T * Q), 空间O(T * Q)。</p>
<pre><code>int get_max_sub_dp(const char* text, const char* query) &#123;
    // Time O(T*Q)
    // Space O(T*Q)
    int T = strlen(text);
    int Q = strlen(query);
    int dp[T][Q];
    for(int i = 0 ; i &lt; T; i ++)
    &#123;
        for(int j = 0; j &lt; Q; j ++)
        &#123;
            dp[i][j] = 0;
        &#125;
    &#125;
    // dp[i][j]表示T[0...i]和Q[0...j]的最大公共子串长度
    int max = -1;
    for (int i = 1; i &lt; T; i++) &#123;
        for (int j = 1; j &lt; Q; j++) &#123;
            if (text[i - 1] == query[j - 1]) &#123;
                dp[i][j] = dp[i-1][j-1] + 1;
                if(max&lt;dp[i][j]) &#123;
                    printf(&quot;dp[%d][%d]\n&quot;, i, j);
                    max=dp[i][j];
                &#125;
            &#125;
        &#125;
    &#125;
    return max;
&#125;
</code></pre>
<h1 id="测试与比较"><a href="#测试与比较" class="headerlink" title="测试与比较"></a>测试与比较</h1><p>首先需要有测试用的text和query，我在Linux环境用Shell命令生成随机字符串。</p>
<pre><code>rm -f in.dat
####生成长度为1000的text字符串到in.dat第一行
tr -cd &#39;[:alnum:]&#39; &lt; /dev/urandom | fold -w1000 | head -n1 &gt; in.dat
####生成长度为100的query字符串到in.dat第一行
tr -cd &#39;[:alnum:]&#39; &lt; /dev/urandom | fold -w100 | head -n1 &gt;&gt; in.dat
</code></pre>
<p>编写C代码，读取text和query，用两种方法进行测试，在标准输出打印所用时间。</p>
<pre><code>#include &lt;sys/time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;time.h&gt;
int timeval_subtract(struct timeval *result, struct timeval *t2, struct timeval *t1)
&#123;
    long int diff = (t2-&gt;tv_usec + 1000000 * t2-&gt;tv_sec) - (t1-&gt;tv_usec + 1000000 * t1-&gt;tv_sec);
    result-&gt;tv_sec = diff / 1000000;
    result-&gt;tv_usec = diff % 1000000;

    return (diff&lt;0);
&#125;
void timeval_print(struct timeval *tv)
&#123;
    char buffer[30];
    time_t curtime;

    printf(&quot;%ld.%06ld&quot;, tv-&gt;tv_sec, tv-&gt;tv_usec);
    curtime = tv-&gt;tv_sec;
    strftime(buffer, 30, &quot;%m-%d-%Y  %T&quot;, localtime(&amp;curtime));
    printf(&quot; = %s.%06ld\n&quot;, buffer, tv-&gt;tv_usec);
&#125;
int main(int argc, char* argv[])
&#123;
    struct timeval tvBegin, tvEnd, tvDiff;
    char *text= NULL;
    char *query= NULL;
    FILE *in = fopen(&quot;in.dat&quot;,&quot;r&quot;);
    size_t len=0;
    if(in==NULL) return -1;
    getline(&amp;text, &amp;len, in);
    getline(&amp;query, &amp;len, in);
    printf(&quot;%s&quot;, text);
    printf(&quot;%s&quot;, query);
    fclose(in);

    // dp
    gettimeofday(&amp;tvBegin, NULL);
    printf(&quot;lcs %d\n&quot;, get_max_sub_dp(text,query));
    gettimeofday(&amp;tvEnd, NULL);
    timeval_subtract(&amp;tvDiff, &amp;tvEnd, &amp;tvBegin);
    printf(&quot;dp time elapsed %ld.%06ld s\n&quot;, tvDiff.tv_sec, tvDiff.tv_usec);

    // br
    gettimeofday(&amp;tvBegin, NULL);
    printf(&quot;lcs %d\n&quot;, get_max_sub_bf(text,query));
    gettimeofday(&amp;tvEnd, NULL);
    timeval_subtract(&amp;tvDiff, &amp;tvEnd, &amp;tvBegin);
    printf(&quot;bf time elapsed %ld.%06ld s\n&quot;, tvDiff.tv_sec, tvDiff.tv_usec);

    return 0;
&#125;
</code></pre>
<p>编译代码<code>gcc common_sub_str.c -o common_sub_str</code></p>
<p>运行./common_sub_str</p>
<p>得出结果：</p>
<pre><code>dp time elapsed 0.002574 s
bf time elapsed 5.522046 s
</code></pre>
<p>实验重复两次，都是得到dp的时间效率高出bf近2000倍。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2014-09-04T10:14:17.000Z" title="9/4/2014, 6:14:17 PM">2014-09-04</time>发表</span><span class="level-item"><time dateTime="2022-04-16T11:47:46.722Z" title="4/16/2022, 7:47:46 PM">2022-04-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/IT/">IT</a></span><span class="level-item">10 分钟读完 (大约1430个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2014/09/04/How-To-Destroy-Singleton/">How To Destroy Singleton</a></h1><div class="content"><blockquote>
<p>Singleton: In software engineering, the singleton pattern is a design pattern that restricts the instantiation of a class to one object. ——Wikipedia</p>
</blockquote>
<h1 id="单例的实现方式"><a href="#单例的实现方式" class="headerlink" title="单例的实现方式"></a>单例的实现方式</h1><p>单例模式主要有以下几种实现方式：</p>
<ol>
<li>枚举方式</li>
<li>饥饿加载</li>
<li>静态块方式</li>
<li>延迟加载</li>
<li>按需加载</li>
</ol>
<h2 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h2><p>在第二版《Effective Java》中Joshua Bloch说，“单元素枚举是实现Singleton的最佳方式”，所有的JVM都支持枚举。这种方式极容易实现，而且不会出现其他方式拥有的“序列化”问题。</p>
<pre><code>public enum Singleton &#123;
    INSTANCE;
    public void execute (
            String arg  // for example
    ) &#123;
        // Perform operation here
    &#125;
&#125;
</code></pre>
<p>这种方式能实现单例的原因，是Java保证任何Enum变量只被实例化一次。Java枚举值是全局可访问的，因此算是被Class Loader延迟加载的单例。它的缺点可能是枚举类型不太灵活。</p>
<h2 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h2><p>如果程序始终需要有一个实例，或者创建实例的开销很大，可以看看饥饿加载，它保证始终都会有一个实例。</p>
<pre><code>public class EagerSingleton &#123;
    private static final EagerSingleton instance = new EagerSingleton();

    private EagerSingleton() &#123;
    &#125;

    public static EagerSingleton getInstance() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<p>这个方法的优势有：</p>
<ol>
<li>当该类被使用时，实例才被创建。</li>
<li>对getInstance()方法不是使用synchronized限制，也就是说所有线程看到的都是同一个实例，没必要使用锁（开销大）。</li>
<li>final关键字说明实例不会被重新定义，保证实例的“有且只有一个”。</li>
</ol>
<h2 id="静态块方式"><a href="#静态块方式" class="headerlink" title="静态块方式"></a>静态块方式</h2><p>与上面的饥饿加载非常类似的一个方式是利用静态块来做一些预处理（例如构造函数异常）。</p>
<pre><code>public class Singleton &#123;
    private static final Singleton instance;

    static &#123;
        try &#123;
            instance = new Singleton();
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(&quot;Darn, an error occurred!&quot;, e);
        &#125;
    &#125;

    public static Singleton getInstance() &#123;
        return instance;
    &#125;

    private Singleton() &#123;
        // ...
    &#125;
&#125;
</code></pre>
<h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>本方法使用双重检查，由于一些细微BUG的存在，只能用于J2SE 5.0以后的版本。存在的问题是：在多线程out of order write环境下，instance可能在构造函数Singleton执行前就返回。</p>
<pre><code>public class SingletonDemo &#123;
    private static volatile SingletonDemo instance = null;

    private SingletonDemo() &#123;
    &#125;

    public static SingletonDemo getInstance() &#123;
        if (instance == null) &#123;
            synchronized (SingletonDemo.class) &#123;
                if (instance == null) &#123;
                    instance = new SingletonDemo();
                &#125;
            &#125;
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<p>另外一个更简单整洁的版本如下，在多线程环境下会有开销大限制并发的问题（锁的开销问题）：</p>
<pre><code>public class SingletonDemo &#123;
    private static volatile SingletonDemo instance = null;

    private SingletonDemo() &#123;
    &#125;

    public static synchronized SingletonDemo getInstance() &#123;
        if (instance == null) &#123;
            instance = new SingletonDemo();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p>这是比以上所有方式都更懒的一种方式，它利用了语言对类初始化的优势，全部JVM适用。</p>
<p>内部类只会在getInstance()被调用之后才被引用，因此这种方式是线程安全的，而且没有用到如synchronized和volatile之类的特殊语言结构。</p>
<pre><code>public class Singleton &#123;
    private Singleton() &#123;
    &#125;

    /**
     * SingletonHolder is loaded on the first execution of Singleton.getInstance()
     * or the first access to SingletonHolder.INSTANCE, not before.
     */
    private static class SingletonHolder &#123;
        private static final Singleton INSTANCE = new Singleton();
    &#125;

    public static Singleton getInstance() &#123;
        return SingletonHolder.INSTANCE;
    &#125;
&#125;
</code></pre>
<h1 id="单例模式的破坏"><a href="#单例模式的破坏" class="headerlink" title="单例模式的破坏"></a>单例模式的破坏</h1><p>尽管程序员正常使用时并不会突破以上各种实现方式的单例设计，但是利用反射和序列化，我们很容易就可以获得单例类的多个实例。以上除了枚举方式之外，都是将构造函数Private化，从而阻止类外调用构造函数。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射是多种高级语言都有的特性，也是元编程的核心所在。它允许程序员在运行中获取类结构、方法、字段，并修改Accessible属性，从而给各种Trick带来了可能。</p>
<p>下面将列出利用反射破坏单例模式的代码：</p>
<pre><code>Constructor constructor = LazySingleton.class.getDeclaredConstructor();
constructor.setAccessible(true);
LazySingleton ls1 = (LazySingleton) constructor.newInstance();
LazySingleton ls2 = (LazySingleton) constructor.newInstance();
LazySingleton ls3 = LazySingleton.getInstance();
LazySingleton ls4 = LazySingleton.getInstance();
System.out.println(ls1 == ls2 ? &quot;单例&quot; : &quot;多例&quot;); //输出“多例”
System.out.println(ls3 == ls4 ? &quot;单例&quot; : &quot;多例&quot;); //输出“单例”
</code></pre>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>从输入输出流中读取Object，如ObjectInputStream.readObject()，实际返回是目标类的readResolve()。如果我们的单例类对该函数没有重写，默认将返回该类的新实例。这就是上面几种实现方式具有的“序列化”问题。</p>
<pre><code>public class InnerLazySingleton implements Serializable &#123;
    private InnerLazySingleton() &#123;
    &#125;

    private static class Inner &#123;
        static final InnerLazySingleton instance = new InnerLazySingleton();
    &#125;

    public static synchronized InnerLazySingleton getInstance() &#123;
        return Inner.instance;
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        InnerLazySingleton ils = InnerLazySingleton.getInstance();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(ils);

        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));
        InnerLazySingleton ils2 = (InnerLazySingleton) ois.readObject();
        System.out.println((ils == ils2 ? &quot;单例&quot; : &quot;多例&quot;)); //输出“多例”
    &#125;
&#125;
</code></pre>
<p>如果在单例类中重写readResolve()，如下，则能达到单例效果。</p>
<pre><code>public class InnerLazySingleton implements Serializable &#123;
    private InnerLazySingleton() &#123;
    &#125;

    private static class Inner &#123;
        static final InnerLazySingleton instance = new InnerLazySingleton();
    &#125;

    public static synchronized InnerLazySingleton getInstance() &#123;
        return Inner.instance;
    &#125;

    private Object readResolve() &#123;
        return getInstance();
    &#125;
&#125;
</code></pre>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="单例和抽象工厂一起使用"><a href="#单例和抽象工厂一起使用" class="headerlink" title="单例和抽象工厂一起使用"></a>单例和抽象工厂一起使用</h2><p>单例模式经常和抽象工厂模式一起使用，来创建一个全局可用但使用者不知道其详细类型的资源。合用这两种模式的一个例子就是Java Abstract Window Tookit（AWT）。</p>
<p>java.awt.Toolkit是将各种AWT组件绑定到特定本地实现的一个抽象类，它有一个Toolkit.getDefaultToolkit()工厂方法返回基于平台实现的子类Toolkit。因为AWT只需要一个对象来执行绑定，而且该对象创建代价较高，所以这个Toolkit被实现为单例。</p>
<p>比较常见的是工厂+单例模式，工厂类一般都被实现为单例。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2014-09-03T10:14:17.000Z" title="9/3/2014, 6:14:17 PM">2014-09-03</time>发表</span><span class="level-item"><time dateTime="2022-04-16T11:47:46.722Z" title="4/16/2022, 7:47:46 PM">2022-04-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/IT/">IT</a></span><span class="level-item">7 分钟读完 (大约1011个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2014/09/03/Pattern-Search-Algorithm-KMP/">Pattern Search Algorithm - KMP</a></h1><div class="content"><h1 id="模式搜索算法KMP"><a href="#模式搜索算法KMP" class="headerlink" title="模式搜索算法KMP"></a>模式搜索算法KMP</h1><p>为了说明算法细节，我们举一个实际例子来说明。假设W=”ABCDABD”，S=”ABC ABCDAB ABCDABCDABDE”。算法的状态在任意时刻都只由两个整数决定：</p>
<p>m表示S中可能匹配W的起始位置<br>i表示W中正在比较的字符下标 每一步中，我们比较S[m+i]和W[i]，如果相等则继续下一个字符。<br>1，从第一个字符开始匹配，因B与A不相等，故后移一位。<br>2，从第一个字符开始匹配，B与A不相等，再次后移。<br>3，直到有一个字符相同，继续往下比较，直到发现不同。<br>4，此时该后移多少？应该后移到如图位置。部分匹配值在后面说明。<br><em>移动位数</em> = 已匹配的字符数 - 对应的部分匹配值<br>根据相同原理，继续进行比较。<br>直到最后i一直匹配到W的最后一位，匹配成功。</p>
<p>6，下面介绍部分匹配值是如何计算的。<br>首先，有两个概念：“前缀”和“后缀”。有如下定义：前缀指除了最后一个字符以外，一个字符串的全部头部组合；“后缀”指除了第一个字符以外，一个字符串的全部尾部组合。<br>在此基础上，“部分匹配值”就是“前缀”和“后缀”中最长的公共元素的长度。以ABCDABD为例：</p>
<p>“A”的前缀和后缀都为空集，共有元素的长度为0；<br>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；<br>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；<br>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；<br>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；<br>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；<br>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p>
<p>“部分匹配”实质是字符串头部和尾部可能有重复的串，搜索移动的时候，我们能通过此规则跳过一定的字符，达到减小复杂度的目的。</p>
<h1 id="KMP算法的效率"><a href="#KMP算法的效率" class="headerlink" title="KMP算法的效率"></a>KMP算法的效率</h1><p>算法的两部分“计算部分匹配值”和“寻找匹配串”，复杂度分别为O(n)和O(k)，因此算法整体复杂度为O(n+k)。这项复杂度不因W和S中的重复模式数目而改变。</p>
<p>最后放上实现代码</p>
<pre><code>public class KMP &#123;
    // kmp算法实现，返回所有匹配处的下标
    static ArrayList&lt;Integer&gt; kmp_search(char[] target, char[] pattern) &#123;
        if (target == null || pattern == null) &#123;
            throw new IllegalArgumentException(&quot;null char array&quot;);// null param
        &#125;
        if (target.length == 0 || pattern.length == 0
                || pattern.length &gt; target.length) &#123;
            throw new IllegalArgumentException(&quot;invalid parameter&quot;);// err return
        &#125;
        int[] pmt = get_pmt(pattern);//获取部分匹配数组
        ArrayList&lt;Integer&gt; kmpResult = new ArrayList&lt;Integer&gt;();
        int S = target.length;// target 元素个数
        int W = pattern.length;// pattern 元素个数
        int delta;//表示patter该往后移动的位数
        int m;// m表示target中可能匹配W的起始位置
        int i;// i表示pattern中正在比较的字符下标
        for (m = 0; m &lt; S - W + 1; m += delta) &#123;
            delta = 1;
            for (i = 0; i &lt; W; i++) &#123;
                if (pattern[i] != target[m + i]) &#123;
                    if (i != 0)
                        delta = (i - pmt[i - 1]);
                    break;
                &#125;
            &#125;
            if (i == W) &#123;
                kmpResult.add(m);
            &#125;
        &#125;
        return kmpResult;
    &#125;

    // 生成部分匹配表
    static int[] get_pmt(char[] pattern) &#123;
        int len = pattern.length;
        int[] pmt = new int[len];
        int i, j, k, max_cc;
        for (i = 0; i &lt; len; i++) &#123;
            max_cc = 0;
            // prefix pattern[0...j]
            // postfix pattern[k...i]
            for (j = 0; j &lt; i; j++) &#123;
                for (k = 0; k &lt;= j; k++) &#123;
                    if (pattern[k] != pattern[i - j + k]) &#123;
                        break;
                    &#125;
                &#125;
                if (k == j + 1)
                    max_cc = Math.max(max_cc, k);
            &#125;
            pmt[i] = max_cc;
        &#125;
        return pmt;
    &#125;

    public static void main(String[] args) &#123;
    // 测试
        char[] target = &quot;AABAACAADAABAAABAA&quot;.toCharArray();
        char[] pattern = &quot;ABAA&quot;.toCharArray();
        System.out.println(kmp_search(target, pattern));
    &#125;
&#125;
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2014-07-21T10:14:17.000Z" title="7/21/2014, 6:14:17 PM">2014-07-21</time>发表</span><span class="level-item"><time dateTime="2022-04-16T11:47:46.722Z" title="4/16/2022, 7:47:46 PM">2022-04-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/IT/">IT</a></span><span class="level-item">6 分钟读完 (大约960个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2014/07/21/How-Does-Namenode-Find-The-Nearest-Datanode/">How Does Namenode Find The Nearest Datanode</a></h1><div class="content"><p>问题的全部：客户端每次都首先与Namenode通信，然后与Namenode指定的Datanode直接读或写数据。这里Namenode会找到离Client最近的Datanode交给Client，请问这个步骤是如何实现的？</p>
<p>根据层次的加深，我有三个不同的答案：</p>
<p>有NameNode确定客户端所在的网络，然后找到一个具有某Blocks的与Client在同一个局域网或机架的数据节点<br>NameNode维护着一个集群的网络拓扑结构，在这个图中可以确定与Client最近的具有某Blocks的数据节点<br>从源码级别来看，NameNode用了什么函数来做这件事情。<br>个人觉得第三个答案是最好的，Talk is cheap, show me the code。</p>
<p>“输入流和输出流是DFSClient实现中最复杂的部分，它们不但需要和名字节点通信，还需要访问数据节点。相比之下，输入流比输出流简单，读数据的过程中，名字节点只提供了两个远程方法，getBlockLocations()和reportBadBlocks()。”</p>
<p>客户端在读取数据前先要向NameNode调用RPC获得BlockLocations，这个过程中NameNode就会提供与客户端最近的数据节点给它。NameNode.getBlockLocations()代码如下：</p>
<pre><code>/**org.apache.hadoop.hdfs.server.namenode.NameNode*/
/** &#123;@inheritDoc&#125; */
public LocatedBlocks getBlockLocations(String src,
    long offset,
    long length) throws IOException &#123;
    myMetrics.incrNumGetBlockLocations();//统计计数
    return namesystem.getBlockLocations(getClientMachine(),
        src, offset, length);//获取BlockLocations
&#125;
/**获取Client的地址*/
private static String getClientMachine() &#123;
    String clientMachine = NamenodeWebHdfsMethods.getRemoteAddress();
    if (clientMachine == null) &#123; //not a web client
        clientMachine = Server.getRemoteAddress();
    &#125;
    if (clientMachine == null) &#123; //not a RPC client
        clientMachine = &quot;&quot;;
    &#125;
    return clientMachine;
&#125;
</code></pre>
<p>重点来了。</p>
<pre><code>/**
 * Get block locations within the specified range.
 *
 * @see #getBlockLocations(String, long, long)
 */
LocatedBlocks getBlockLocations(String clientMachine, String src,
        long offset, long length) throws IOException &#123;
    LocatedBlocks blocks = getBlockLocations(src, offset, length, true,
            true, true);// 1，获取源文件所在的所有Block
    if (blocks != null) &#123;
        // sort the blocks 2，打算将这些Block按从近到远进行排序
        // In some deployment cases, cluster is with separation of task
        // tracker
        // and datanode which means client machines will not always be
        // recognized
        // as known data nodes, so here we should try to get node (but not
        // datanode only) for locality based sort.
        Node client = host2DataNodeMap.getDatanodeByHost(clientMachine);// 3，查看client是否是DataNode节点
        if (client == null) &#123;// 3.1，若不是，则对client进行dns解析生成一个NodeBase
            List&lt;String&gt; hosts = new ArrayList&lt;String&gt;(1);
            hosts.add(clientMachine);
            String rName = dnsToSwitchMapping.resolve(hosts).get(0);
            if (rName != null)
                client = new NodeBase(clientMachine, rName);
        &#125;

        DFSUtil.StaleComparator comparator = null;
        if (avoidStaleDataNodesForRead) &#123;
            comparator = new DFSUtil.StaleComparator(staleInterval);
        &#125;
        // Note: the last block is also included and sorted
        // 4，将所有Block所在位置与Client进行比较，然后按比较结果从小到大排序
        for (LocatedBlock b : blocks.getLocatedBlocks()) &#123;
            // 4.1，使用NetworkTopology实例clusterMap进行排序
            clusterMap.pseudoSortByDistance(client, b.getLocations());
            if (avoidStaleDataNodesForRead) &#123;
                Arrays.sort(b.getLocations(), comparator);
            &#125;
        &#125;
    &#125;
    return blocks;
&#125;
</code></pre>
<p>排序代码</p>
<pre><code>/**
 * Get block locations within the specified range.
 *
 * @see #getBlockLocations(String, long, long)
 */
LocatedBlocks getBlockLocations(String clientMachine, String src,
        long offset, long length) throws IOException &#123;
    LocatedBlocks blocks = getBlockLocations(src, offset, length, true,
            true, true);// 1，获取源文件所在的所有Block
    if (blocks != null) &#123;
        // sort the blocks 2，打算将这些Block按从近到远进行排序
        // In some deployment cases, cluster is with separation of task
        // tracker
        // and datanode which means client machines will not always be
        // recognized
        // as known data nodes, so here we should try to get node (but not
        // datanode only) for locality based sort.
        Node client = host2DataNodeMap.getDatanodeByHost(clientMachine);// 3，查看client是否是DataNode节点
        if (client == null) &#123;// 3.1，若不是，则对client进行dns解析生成一个NodeBase
            List&lt;String&gt; hosts = new ArrayList&lt;String&gt;(1);
            hosts.add(clientMachine);
            String rName = dnsToSwitchMapping.resolve(hosts).get(0);
            if (rName != null)
                client = new NodeBase(clientMachine, rName);
        &#125;

        DFSUtil.StaleComparator comparator = null;
        if (avoidStaleDataNodesForRead) &#123;
            comparator = new DFSUtil.StaleComparator(staleInterval);
        &#125;
        // Note: the last block is also included and sorted
        // 4，将所有Block所在位置与Client进行比较，然后按比较结果从小到大排序
        for (LocatedBlock b : blocks.getLocatedBlocks()) &#123;
            // 4.1，使用NetworkTopology实例clusterMap进行排序
            clusterMap.pseudoSortByDistance(client, b.getLocations());
            if (avoidStaleDataNodesForRead) &#123;
                Arrays.sort(b.getLocations(), comparator);
            &#125;
        &#125;
    &#125;
    return blocks;
&#125;
</code></pre>
<p>至此，这个过程算是大概明白了。但是还需要结合整个Namenode的数据结构来看才行，不然就一叶障目不见泰山了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2014-07-19T10:14:17.000Z" title="7/19/2014, 6:14:17 PM">2014-07-19</time>发表</span><span class="level-item"><time dateTime="2022-04-16T11:47:46.722Z" title="4/16/2022, 7:47:46 PM">2022-04-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/IT/">IT</a></span><span class="level-item">2 分钟读完 (大约284个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2014/07/19/Pointers-And-References/">Pointers And References</a></h1><div class="content"><p>指针与引用的区别有：</p>
<ol>
<li>非空区别。指针可以为空，而引用不能。</li>
<li>合法性区别。在使用之前指针必须验证合法性，而引用则不用。</li>
<li>可修改区别。指针可以被重新赋值以指向不同的对象，而引用则总是在初始化时就固定地指向某对象，过后不可修改，但指向的对象内容可以更改。</li>
<li>应用区别。两种情况下应使用指针：1，存在不指向任何对象的可能；2，需要在不同时刻指向不同的对象。如果总是指向一个对象且一直不变，则使用引用。</li>
</ol>
<p>代码实例：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() &#123;
    int iv;
    int iv2 = 1024;
    int iv3 = 999;
    int &amp;reiv; // 编译错误，引用声明时未初始化
    int &amp;reiv2 = iv;
    int &amp;reiv3 = iv;
    int *pi; *pi = 5;//运行时错误，欲修改未知地址的内容
    cout &lt;&lt; pi &lt;&lt; endl; pi = &amp;iv3;
    cout &lt;&lt; pi &lt;&lt; endl;
    const double di;//编译错误，const常量声明时未初始化
    const double maxWage = 10.0;
    const double minWage = 0.5;
    const double *pc = &amp;maxWage;
    return 0;
&#125;
</code></pre>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/8/">上一页</a></div><div class="pagination-next"><a href="/page/10/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/8/">8</a></li><li><a class="pagination-link is-current" href="/page/9/">9</a></li><li><a class="pagination-link" href="/page/10/">10</a></li><li><a class="pagination-link" href="/page/11/">11</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/about/index/logo.svg" alt="CAISKI"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">CAISKI</p><p class="is-size-6 is-block">Engineer at Tencent Inc.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">55</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">24</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/caiski" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/caiski"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/imskicai"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="/PostgresWorld" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Postgres World</span></span><span class="level-right"><span class="level-item tag">/PostgresWorld</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/IT/"><span class="level-start"><span class="level-item">IT</span></span><span class="level-end"><span class="level-item tag">35</span></span></a></li><li><a class="level is-mobile" href="/categories/Other/"><span class="level-start"><span class="level-item">Other</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-01T12:02:38.000Z">2022-07-01</time></p><p class="title"><a href="/2022/07/01/Commonly-Used-Tools-Website-v2022/">Commonly Used Tools Website v2022</a></p><p class="categories"><a href="/categories/Other/">Other</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-10T03:01:05.000Z">2021-10-10</time></p><p class="title"><a href="/2021/10/10/Li-Assisted-Driving-in-Long-Distance-Road-Trip/">Li Assisted Driving in Long Distance Road Trip</a></p><p class="categories"><a href="/categories/Other/">Other</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-22T07:16:56.000Z">2021-08-22</time></p><p class="title"><a href="/2021/08/22/Data-Type-Mappings-Between-Golang-And-PostgreSQL/">Data Type Mappings Between Golang And PostgreSQL</a></p><p class="categories"><a href="/categories/IT/">IT</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-18T05:16:42.000Z">2021-07-18</time></p><p class="title"><a href="/2021/07/18/A-Glance-Through-the-Window-of-Office-Two-Pictures/">A Glance Through the Window of Office (Two Pictures)</a></p><p class="categories"><a href="/categories/Other/">Other</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-17T12:14:17.000Z">2021-07-17</time></p><p class="title"><a href="/2021/07/17/Alfred-New-User-Notes-Part-I/">Alfred New User Notes - Part I</a></p><p class="categories"><a href="/categories/Other/">Other</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/08/"><span class="level-start"><span class="level-item">八月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/07/"><span class="level-start"><span class="level-item">七月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">一月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/12/"><span class="level-start"><span class="level-item">十二月 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/11/"><span class="level-start"><span class="level-item">十一月 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/10/"><span class="level-start"><span class="level-item">十月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/12/"><span class="level-start"><span class="level-item">十二月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/11/"><span class="level-start"><span class="level-item">十一月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/09/"><span class="level-start"><span class="level-item">九月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/08/"><span class="level-start"><span class="level-item">八月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/07/"><span class="level-start"><span class="level-item">七月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/06/"><span class="level-start"><span class="level-item">六月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/04/"><span class="level-start"><span class="level-item">四月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/12/"><span class="level-start"><span class="level-item">十二月 2014</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/09/"><span class="level-start"><span class="level-item">九月 2014</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/07/"><span class="level-start"><span class="level-item">七月 2014</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/09/"><span class="level-start"><span class="level-item">九月 2013</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2012/09/"><span class="level-start"><span class="level-item">九月 2012</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2012/07/"><span class="level-start"><span class="level-item">七月 2012</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2010/12/"><span class="level-start"><span class="level-item">十二月 2010</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2010/11/"><span class="level-start"><span class="level-item">十一月 2010</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/alfred/"><span class="tag">alfred</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/algorithm/"><span class="tag">algorithm</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/blockchain/"><span class="tag">blockchain</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpp/"><span class="tag">cpp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/design-pattern/"><span class="tag">design pattern</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/emerg/"><span class="tag">emerg</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iptables/"><span class="tag">iptables</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mac/"><span class="tag">mac</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/photography/"><span class="tag">photography</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgresql/"><span class="tag">postgresql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/regex/"><span class="tag">regex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rpc/"><span class="tag">rpc</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssh/"><span class="tag">ssh</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tex/"><span class="tag">tex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thoughts/"><span class="tag">thoughts</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tool/"><span class="tag">tool</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/trial/"><span class="tag">trial</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tricks/"><span class="tag">tricks</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/about/index/logo.svg" alt="Slack Ideas" height="28"></a><p class="is-size-7"><span>&copy; 2022 caiski</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>